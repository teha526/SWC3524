
import java.util.*;

public class MaritimeReliefRouteOptimization {
    // Distance Matrix (Adjacency Matrix)
    static int[][] distanceMatrix = {
        {0, 15, 25, 35},
        {15, 0, 30, 28},
        {25, 30, 0, 20},
        {35, 28, 20, 0}
    };
    
    // Location names
    static String[] locations = {"Port A", "Port B", "Relief Center C", "Relief Center D"};
    
    public static void main(String[] args) {
        //greed algorithm
        System.out.println("=== Relief Route Optimization (Greedy Algorithm) ===");
        String greedyResult = greedyTSP(distanceMatrix);
        System.out.println(greedyResult);
        
        //dynamic programming
        System.out.print("\n");
         // Run the DP-based route optimization and print the result
        String result = dynamicProgrammingTSP(distanceMatrix);
        System.out.println(result);
        
        //backtracking
        System.out.print("\n");
        System.out.println(backtrackingTSP(distanceMatrix));
        
        //divide and conquer
        System.out.print("\n");
        System.out.println(divideAndConquerTSP(distanceMatrix));   
        
        //insertion sort
        System.out.print("\n");
        int[] distances = {5, 1, 9, 3, 8, 2};
        System.out.println(insertionSort(distances));
        
        //binary search
        System.out.println(binarySearch(distances, 5));
        
        //heap
        System.out.print("\n");
        Heap<Integer> minHeap = new Heap<>(true);  // Min-Heap for urgent deliveries
        minHeap.insert(10);  // Low urgency
        minHeap.insert(3);   // High urgency (process first)
        minHeap.insert(15);  // Medium urgency
        System.out.println("Min-Heap Extract Min: " + minHeap.extractMin());  // Outputs 3
        
        
        // Splay Tree 
        SplayTree tree = new SplayTree();
        tree.insert(20);
        tree.insert(10);
        tree.insert(30);
        System.out.println("Splay Tree Search (10 found): " + tree.search(10));
        

    }

     // Greedy TSP 
    public static String greedyTSP(int[][] dist)  
    { 
         int n = dist.length;
            boolean[] visited = new boolean[n];
            int currentCity = 0; // Start from Port A
            visited[currentCity] = true;
            int totalDistance = 0;
            StringBuilder route = new StringBuilder();
            route.append(locations[currentCity]);

            for (int i = 0; i < n - 1; i++) {
                int nearestCity = -1;
                int minDist = Integer.MAX_VALUE;

                // Find nearest unvisited city
                for (int j = 0; j < n; j++) {
                    if (!visited[j] && dist[currentCity][j] < minDist) {
                        minDist = dist[currentCity][j];
                        nearestCity = j;
                    }
                }

                visited[nearestCity] = true;
                totalDistance += minDist;
                route.append(" -> ").append(locations[nearestCity]);
                currentCity = nearestCity;
            }

            // Return to start
            totalDistance += dist[currentCity][0];
            route.append(" -> ").append(locations[0]);

            return "Greedy TSP Route :" + route + " Total Distance  : " + totalDistance + "nm ";
            
    }
  
    
    //dynamic programming
     /**
     * Solves the Relief Route Optimization Problem (RROP)
     * using Dynamic Programming with recursion and memoization.
     */
    public static String dynamicProgrammingTSP(int[][] dist) {
        int n = dist.length;                // number of ports/centers
        int VISITED_ALL = (1 << n) - 1;     // all locations visited (binary 1111 for 4 locations)

        // memo[mask][pos] stores the minimum cost from this state
        int[][] memo = new int[1 << n][n];
        for (int[] row : memo) Arrays.fill(row, -1); // initialize with -1 (uncomputed)

        // paths[mask][pos] stores the optimal route string for this state
        String[][] paths = new String[1 << n][n];

        // Start from Port A (index 0) with only Port A visited (mask = 0001)
        int minCost = dynamicProgrammingTSPHelper(0, 1, dist, memo, VISITED_ALL, paths);

        // Retrieve and finalize the optimal route path from the stored paths table
        String bestPath = paths[1][0] + " → Port A";

        return " Dynamic Programming Optimal Maritime Relief Route:\n" + bestPath +
               "\nTotal Distance: " + minCost + " nautical miles";
    }

    /**
     * Recursive DP helper function for the TSP / Relief Route Optimization.
     *
     * @param pos        current position (port or relief center)
     * @param mask       bitmask of visited locations
     * @param dist       distance matrix
     * @param memo       DP table for memoization
     * @param VISITED_ALL bitmask representing all locations visited
     * @param paths      stores the corresponding optimal path strings
     * @return minimum cost from current state
     */
    private static int dynamicProgrammingTSPHelper(
            int pos, int mask, int[][] dist, int[][] memo,
            int VISITED_ALL, String[][] paths) {

        int n = dist.length;

        //  Base Case: all locations have been visited
        if (mask == VISITED_ALL) {
            // Save the current city name in the path
            paths[mask][pos] = getName(pos);
            // Return distance to go back to Port A (the starting point)
            return dist[pos][0];
        }

        // If already computed, return the stored result
        if (memo[mask][pos] != -1) {
            return memo[mask][pos];
        }

        int minCost = Integer.MAX_VALUE; // stores minimum cost found
        String bestPath = "";            // stores corresponding best path

        //  Try to go to all other unvisited cities
        for (int city = 0; city < n; city++) {
            // Skip if this city is already visited (check using bitmask)
            if ((mask & (1 << city)) == 0) {
                // Mark this city as visited by turning on its bit
                int newMask = mask | (1 << city);

                // Recursive call: cost of traveling to 'city' + cost of visiting remaining cities
                int newCost = dist[pos][city] +
                        dynamicProgrammingTSPHelper(city, newMask, dist, memo, VISITED_ALL, paths);

                // If this route gives a smaller cost, update minCost and store path
                if (newCost < minCost) {
                    minCost = newCost;
                    // Build the path string: current city → optimal path of the next stage
                    bestPath = getName(pos) + " → " + paths[newMask][city];
                }
            }
        }

        //  Store results in memo and paths tables
        memo[mask][pos] = minCost;
        paths[mask][pos] = bestPath;

        // Return the best (minimum) cost for this state
        return minCost;
    }

    /**
     * Converts an index (0–3) to a human-readable port or relief center name.
     */
    private static String getName(int index) {
        return switch (index) {
            case 0 -> "Port A";
            case 1 -> "Port B";
            case 2 -> "Relief Center C";
            case 3 -> "Relief Center D";
            default -> "Unknown";
        };
    }
    
    
    
     // === Backtracking TSP main function ===
    public static String backtrackingTSP(int[][] dist) {
        int n = dist.length;
        boolean[] visited = new boolean[n];
        visited[0] = true; // start from Port A

        StringBuilder bestPath = new StringBuilder();
        StringBuilder currentPath = new StringBuilder(locations[0]);
        int[] minCost = {Integer.MAX_VALUE}; // store min cost as array to modify inside recursion

        tspBacktracking(0, dist, visited, n, 1, 0, currentPath, bestPath, minCost);

        return "Backtracking Optimal Route: " + bestPath.toString() + " → " + locations[0] +
               "\nMinimum Distance: " + minCost[0] + " nautical miles";
    }

    // === Recursive Backtracking Helper ===
    private static void tspBacktracking(int pos, int[][] dist, boolean[] visited, int n,
                                        int count, int cost, StringBuilder path,
                                        StringBuilder bestPath, int[] minCost) {

        // Base case: all locations visited
        if (count == n && dist[pos][0] > 0) {
            int totalCost = cost + dist[pos][0];
            if (totalCost < minCost[0]) {
                minCost[0] = totalCost;
                bestPath.setLength(0);
                bestPath.append(path.toString());
            }
            return;
        }

        // Try next unvisited locations
        for (int i = 0; i < n; i++) {
            if (!visited[i] && dist[pos][i] > 0) {
                visited[i] = true;
                path.append(" → ").append(locations[i]);

                tspBacktracking(i, dist, visited, n, count + 1,
                                cost + dist[pos][i], path, bestPath, minCost);

                // Backtrack
                visited[i] = false;
                int lastArrowIndex = path.lastIndexOf(" → ");
                path.setLength(lastArrowIndex);
            }
        }
    }
    
    // Divide and Conquer TSP
    public static String divideAndConquerTSP(int[][] dist) {
        int n = dist.length;
        boolean[] visited = new boolean[n];
        visited[0] = true;  // Start from Port A (index 0)
        StringBuilder currentPath = new StringBuilder(locations[0]);
        StringBuilder bestPath = new StringBuilder();
        int[] minCost = {Integer.MAX_VALUE};
        
        divideAndConquerHelper(0, visited, 0, dist, n, currentPath, bestPath, minCost);
        
        return "Divide & Conquer TSP Route: " + bestPath.toString() + " | Total Distance: " + minCost[0] + " nm";
    }
    
    private static void divideAndConquerHelper(int pos, boolean[] visited, int currentCost, int[][] dist, int n, StringBuilder currentPath, StringBuilder bestPath, int[] minCost) {
        if (allVisited(visited)) {
            int returnCost = currentCost + dist[pos][0];  // Add cost to return to start
            if (returnCost < minCost[0]) {
                minCost[0] = returnCost;
                bestPath.setLength(0);
                bestPath.append(currentPath).append(" -> ").append(locations[0]);
            }
            return;
        }
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                visited[i] = true;
                int prevLength = currentPath.length();
                currentPath.append(" -> ").append(locations[i]);
                divideAndConquerHelper(i, visited, currentCost + dist[pos][i], dist, n, currentPath, bestPath, minCost);
                currentPath.setLength(prevLength);
                visited[i] = false;
            }
        }
        
    }
    
    private static boolean allVisited(boolean[] visited) {
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }

       // Insertion Sort
    public static String insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
        StringBuilder sortedArray = new StringBuilder("Sorted Array: [");
        for (int i = 0; i < arr.length; i++) {
            sortedArray.append(arr[i]);
            if (i < arr.length - 1) sortedArray.append(", ");
        }
        sortedArray.append("]");
        return sortedArray.toString();
    }

    // Binary Search
    public static String binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return "Binary Search (" + target + " found at index): " + mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return "Binary Search (" + target + " not found in array)";
    }

    
    // Heap (Min-Heap & Max-Heap)
    static class Heap<T extends Comparable<T>> {
        private List<T> heap;
        private Comparator<T> comparator;  // For Min-Heap or Max-Heap
        
        public Heap(boolean isMinHeap) {
            heap = new ArrayList<>();
            comparator = isMinHeap ? Comparator.naturalOrder() : Comparator.reverseOrder();
        }
        
        public void insert(T value) {
            heap.add(value);
            heapifyUp(heap.size() - 1);
        }
        
        public T extractMin() {  // For Min-Heap; for Max-Heap, rename to extractMax
            if (heap.isEmpty()) throw new IllegalStateException("Heap is empty");
            T root = heap.get(0);
            T last = heap.remove(heap.size() - 1);
            if (!heap.isEmpty()) {
                heap.set(0, last);
                heapifyDown(0);
            }
            return root;
        }
        
        public T peek() {
            if (heap.isEmpty()) throw new IllegalStateException("Heap is empty");
            return heap.get(0);
        }
        
        private void heapifyUp(int index) {
            while (index > 0) {
                int parent = (index - 1) / 2;
                if (comparator.compare(heap.get(index), heap.get(parent)) >= 0) break;
                swap(index, parent);
                index = parent;
            }
        }
        
        private void heapifyDown(int index) {
            int size = heap.size();
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                int smallest = index;
                if (left < size && comparator.compare(heap.get(left), heap.get(smallest)) < 0) smallest = left;
                if (right < size && comparator.compare(heap.get(right), heap.get(smallest)) < 0) smallest = right;
                if (smallest == index) break;
                swap(index, smallest);
                index = smallest;
            }
        }
        
        private void swap(int i, int j) {
            T temp = heap.get(i);
            heap.set(i, heap.get(j));
            heap.set(j, temp);
        }
    }
    
    // Splay Tree
    static class SplayTree {
        static class Node {
            int key;
            Node left, right, parent;
            
            Node(int key) {
                this.key = key;
            }
        }
        
        private Node root;
        
        public void insert(int key) {
            if (root == null) {
                root = new Node(key);
                return;
            }
            Node node = root;
            Node parent = null;
            while (node != null) {
                parent = node;
                if (key < node.key) node = node.left;
                else if (key > node.key) node = node.right;
                else return;  // Key already exists
            }
            Node newNode = new Node(key);
            newNode.parent = parent;
            if (key < parent.key) parent.left = newNode;
            else parent.right = newNode;
            splay(newNode);
        }
        
        public boolean search(int key) {
            Node node = searchNode(key);
            if (node != null) {
                splay(node);
                return true;
            }
            return false;
        }
        
        private Node searchNode(int key) {
            Node node = root;
            while (node != null) {
                if (key < node.key) node = node.left;
                else if (key > node.key) node = node.right;
                else return node;
            }
            return null;
        }
        
        private void splay(Node node) {
            while (node.parent != null) {
                if (node.parent.parent == null) {
                    // Zig or Zag
                    if (node == node.parent.left) rotateRight(node.parent);
                    else rotateLeft(node.parent);
                } else if (node == node.parent.left && node.parent == node.parent.parent.left) {
                    // Zig-Zig
                    rotateRight(node.parent.parent);
                    rotateRight(node.parent);
                } else if (node == node.parent.right && node.parent == node.parent.parent.right) {
                    // Zag-Zag
                    rotateLeft(node.parent.parent);
                    rotateLeft(node.parent);
                } else {
                    // Zig-Zag or Zag-Zig
                    if (node == node.parent.left) rotateRight(node.parent);
                    else rotateLeft(node.parent);
                    if (node.parent.left == node) rotateRight(node.parent);
                    else rotateLeft(node.parent);
                }
            }
            root = node;
        }
        
        private void rotateLeft(Node node) {
            Node right = node.right;
            node.right = right.left;
            if (right.left != null) right.left.parent = node;
            right.parent = node.parent;
            if (node.parent == null) root = right;
            else if (node == node.parent.left) node.parent.left = right;
            else node.parent.right = right;
            right.left = node;
            node.parent = right;
        }
        
        private void rotateRight(Node node) {
            Node left = node.left;
            node.left = left.right;
            if (left.right != null) left.right.parent = node;
            left.parent = node.parent;
            if (node.parent == null) root = left;
            else if (node == node.parent.right) node.parent.right = left;
            else node.parent.left = left;
            left.right = node;
            node.parent = left;
        }
        
        
      
    
}
    }



  
        
    
